import bokehlib.coord as co
from bokeh.plotting import figure, show, output_file
from bokeh.models import WMTSTileSource, ColumnDataSource, HoverTool, PointDrawTool, LabelSet, Label, ColorBar, LinearColorMapper, ArrowHead, NormalHead, OpenHead,Arrow, VeeHead
from bokeh.io import output_notebook, push_notebook, show, output_file, export_png
from bokeh.resources import Resources
from bokeh import palettes
from scipy.interpolate import interp1d
from pyproj import transform, Proj
import pandas as pd
import numpy as np


color_variable = "ip_address"
time_variable = "START_TIME"


def convert_coords(coords):
    
    inProj = Proj(init='epsg:4326') #latlong
    outProj = Proj(init='epsg:3857') # mercator
    
    if isinstance(coords, pd.core.frame.DataFrame):
        
        long_lat = [tuple(x) for x in coords.values]

        merc_xy = [transform(inProj, outProj, x, y) for x,y in long_lat]
        merc_x = [x[0] for x in merc_xy]
        merc_y = [x[1] for x in merc_xy]
    
    else:
        merc_xy = transform(inProj, outProj, coords[0], coords[1])
        merc_x = merc_xy[0]
        merc_y = merc_xy[1]
    
    return merc_x, merc_y


 
    

def create_colormap(active_proc_df,column,typ="cat"):
    big_color_map = []
    if typ=="cat":
        big_color_map.extend(palettes.Category20[20])
        big_color_map.extend(palettes.Category20b[20])
        big_color_map.extend(palettes.Category20c[20])
    elif typ=="cont":
        big_color_map = palettes.Inferno256
    
    
    
    if column:
        extra_m = interp1d([0,int(active_proc_df[column].max())],[0,255],fill_value='extrapolate')
        colormap = {key:big_color_map[int(extra_m(index))] for index,key in enumerate(active_proc_df[column].unique())}
        colors = [colormap[x] for x in active_proc_df[column]]
    else:
        colormap = {key:big_color_map[index] for index,key in enumerate(active_proc_df[color_variable].unique())}
        colors = [colormap[x] for x in active_proc_df[color_variable]]
    
    return colors,colormap

def plot_points_seperate(row,p,kc,active_proc_df):
    colors,colormap = create_colormap(active_proc_df)
    
    if (row['Latitude'],row['Longitude']) not in kc:
        kc.append((row['Latitude'],row['Longitude']))
        multi_point_df = active_proc_df.where((active_proc_df['Longitude'] == row['Longitude']) & (active_proc_df['Latitude'] == row['Latitude'])).dropna()
        
        center_lon = co.merc_x(float(row['Longitude']))
        center_lat = co.merc_y(float(row['Latitude']))
        if multi_point_df.shape[0] > 1:
            
           
            p.circle(x=center_lon,y=center_lat, size=2,color='red')
            y_off = 0.003
            x_off = 0.005                       
            for inner_row in multi_point_df.iterrows():
                adjust_lon = co.merc_x(float(row['Longitude'])+x_off)
                adjust_lat = co.merc_y(float(row['Latitude'])+y_off)
                
                p.circle(x=adjust_lon,
                         y=adjust_lat, 
                         size=8,
                         color=colormap[inner_row[1][color_variable]],
                         legend= str(inner_row[1][color_variable]))
                
                p.line(x=[center_lon,adjust_lon],
                       y=[center_lat,adjust_lat])
                
                label = Label(x=adjust_lon,
                              y=adjust_lat,
                              text="{}\n{}".format(inner_row[1][color_variable],inner_row[1][time_variable]),
                              text_font_size='9pt')
                p.add_layout(label)
                
        
                y_off = y_off - 0.001
        else:

            p.circle(x=center_lon,
                     y=center_lat, 
                     size=8, 
                     color=colormap[row[color_variable]],
                     legend= str(row[color_variable]))
            label = Label(x=center_lon,
                          y=center_lat,
                          text="{}\n{}".format(row[color_variable],row[time_variable]),
                          text_font_size='9pt')
            p.add_layout(label)
            

    
def plot_points(row, p):
    
    center_x = row['merc_x']
    center_y = row['merc_y']
    
    p.circle(x=center_x,
             y=center_y, 
             size=20,
             fill_alpha=0.5)

    
    
def plot_points_heatmap(row, p, extra_m):
    
    center_lon = row['merc_x']
    center_lat = row['merc_y']
    
    if not np.isnan(row['count']):
            
        p.circle(x=center_lon,
             y=center_lat, 
             size=int(row['count'])+5,
             fill_alpha=0.5,
             color=palettes.Inferno256[int(extra_m(int(row['count'])))])
    #else:
    #    p.circle(x=center_lon,
    #         y=center_lat, 
    #         size=15,
    #         fill_alpha=0)
             



def plot_points_time(row, p, df, colors=""):
    
    
    center_x = row['merc_x']
    center_y = row['merc_y']
    

    if colors:
        p.circle(x=center_x,
                 y=center_y, 
                 size=1,
                 fill_color=colors[row.name],
                 legend=row[time_variable],
                 alpha=1)
        
    else:
        p.circle(x=center_x,
                 y=center_y, 
                 size=15)

       

    if row.name > 0:
        previous_x = df['merc_x'][row.name-1]
        previous_y = df['merc_y'][row.name-1]
        
        if colors:
            arrow = Arrow(end=VeeHead(size=30, fill_color=colors[row.name]),
                          start=OpenHead(size=12, line_color=colors[row.name-1]),
                          x_start=previous_x,
                          x_end=center_x,
                          y_start=previous_y,
                          y_end=center_y,
                          line_color=colors[row.name],
                          line_width=10)
        else:
            arrow = Arrow(end=VeeHead(size=10),
                          x_start=previous_x,
                          x_end=center_x,
                          y_start=previous_y,
                          y_end=center_y)
        p.add_layout(arrow)
