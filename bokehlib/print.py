import bokehlib.prepare as prep
import bokehlib.rowplotter as rowp
import bokehlib.plots_misc as pltmisc
import bokehlib.helper as h
import pandas as pd

from bokeh.plotting import figure, show, output_file
from bokeh.models import WMTSTileSource, ColumnDataSource, HoverTool, PointDrawTool, LabelSet, Label, ColorBar, LinearColorMapper, ArrowHead, Arrow, VeeHead, CustomJS, TapTool
from bokeh.io import output_notebook, push_notebook, show, output_file, export_png, export_svgs
from bokeh.resources import Resources
from bokeh import palettes
from scipy.interpolate import interp1d
import time
import numpy as np


BOKEH_RESOURCES = "inline"
tiles = {'OpenMap':WMTSTileSource(url='http://192.168.178.48/maps/{z}/{x}/{y}.png ')}
res = Resources(mode='server', root_url='http://192.168.178.48/res/')

output_notebook(resources=res)

def find_merc_min_max(active_date_df):
    
    active_date_df['Longitude'] = active_date_df['Longitude'].astype(float)
    active_date_df['Latitude'] = active_date_df['Latitude'].astype(float)

    
    merc_min = rowp.convert_coords((active_date_df['Longitude'].min()-0.01, active_date_df['Latitude'].min()-0.01))
    merc_max = rowp.convert_coords((active_date_df['Longitude'].max()+0.01, active_date_df['Latitude'].max()+0.01))

    return (merc_min, merc_max)


def prepare_plot(df, title="Title",plot_width=1200, plot_height=1200, tooltip=""):
    
    TOOLS="hover,crosshair,pan,wheel_zoom,box_zoom,reset,tap,save,box_select,poly_select,lasso_select"
    merc_min, merc_max = find_merc_min_max(df)
    if tooltip:
        p = figure (x_range=(merc_min[0], merc_max[0]),
                    y_range=(merc_min[1], merc_max[1]),
                    x_axis_type='mercator',
                    y_axis_type='mercator',
                    plot_width=plot_width,
                    plot_height=plot_height,
                    title=title,
                    tooltips=tooltip,
                    tools=TOOLS)
    
    else:
        p = figure (x_range=(merc_min[0], merc_max[0]),
                    y_range=(merc_min[1], merc_max[1]),
                    x_axis_type='mercator',
                    y_axis_type='mercator',
                    plot_width=plot_width,
                    plot_height=plot_height,
                    title=title)
    
    p.title.text_font_size = '15pt'
    
    return (merc_min, merc_max, p)


def print_points(df , title="Title", export=False, showplot=True):

    
    merc_min, merc_max, p = prepare_plot(df, title)
        
        
    _ = df.apply(rowp.plot_points,args=(p,),axis=1)    
    
    p.add_tile(tiles['OpenMap'])
    
    if showplot:
        show(p)
    else:
        return p
        
def print_points_heatmap(df, title="Title", export=False, showplot=True):
    
    
    merc_min, merc_max, p = prepare_plot(df, title)
    
    kc = []
    df['count'] = df.apply(h.count_multi_points, args=(kc, df,), axis=1)

    extra_m = interp1d([0,len(df)],[0,255],fill_value='extrapolate')
    
    _ = df.apply(rowp.plot_points_heatmap, args=(p, extra_m,), axis=1)
    
    p.add_tile(tiles['OpenMap'])
    
    color_mapper = LinearColorMapper(palette="Inferno256", low=0, high=len(df))
    color_bar = ColorBar(color_mapper=color_mapper,
                     label_standoff=12, 
                     border_line_color=None, 
                     location=(0,0))
    
    p.add_layout(color_bar, 'right')
    
    if showplot:
        show(p)
    else:
        return p
    
def print_points_heatmap_interactive(df, title="Title", export=False, showplot=True):
    
    
    kc = []
    plot_df = pd.DataFrame()
    temp = df.apply(h.count_multi_points_ip, args=(kc, df,), axis=1)

    temp =  [row for index,row in temp.iterrows() if not (np.isnan(row['count']))] 
    for row in temp:
        plot_df = plot_df.append(row)

    # better visibility of small points
    plot_df['vis_count'] = plot_df['count'] + 5
    
    colors, colormap = rowp.create_colormap(plot_df, "count", typ="cont")
    
    source = ColumnDataSource(data=dict(
        x=plot_df['merc_x'],
        y=plot_df['merc_y'],
        count=plot_df['count'],
        vis_count=plot_df['vis_count'],
        domain=plot_df['domain'],
        ip=plot_df['ip'],
        color=colors    
    ))

    TOOLTIPS = [
        ("Count", "@count"),
        ("Domains", "@domain"),
        ("IPs", "@ip"),
    ]

    TOOLTIPS = [
        ("Count", "@count"),
        ("Domains", "<span style='width:50px, overflow-y:auto;'>@domain</span>"),
        ("IPs", "@ip"),
    ]
    
    merc_min, merc_max, p = prepare_plot(df, title, tooltip=TOOLTIPS)
    
    
    p.circle('x', 'y', 
             size='vis_count', 
             source=source,
             fill_alpha=0.5,
             color='color')
    
    p.add_tile(tiles['OpenMap'])
  
    
    if showplot:
        show(p)
    else:
        return p
    

def print_points_heatmap_interactive_customjs(df, title="Title", export=False, showplot=True):
    
    
    kc = []
    plot_df = pd.DataFrame()
    temp = df.apply(h.count_multi_points_ip, args=(kc, df,), axis=1)

    temp =  [row for index,row in temp.iterrows() if not (np.isnan(row['count']))] 
    for row in temp:
        plot_df = plot_df.append(row)

    # better visibility of small points
    plot_df['vis_count'] = plot_df['count'] + 5
    
    colors, colormap = rowp.create_colormap(plot_df, "count", typ="cont")
    
    
    source = ColumnDataSource(data=dict(
        x=plot_df['merc_x'],
        y=plot_df['merc_y'],
        count=plot_df['count'],
        vis_count=plot_df['vis_count'],
        domain=plot_df['domain'],
        ip=plot_df['ip'],
        color=colors    
    ))

    TOOLTIPS = [
        ("Count", "@count"),
        ("Domains", "@domain"),
        ("IPs", "@ip"),
    ]

    
    merc_min, merc_max, p = prepare_plot(df, title, tooltip=TOOLTIPS)
    
    
    p.circle('x', 'y', 
             size='vis_count', 
             source=source,
             fill_alpha=0.5,
             color='color')
    
    p.add_tile(tiles['OpenMap'])
    
    tapcallback = CustomJS(args=dict(source=source), code="""
        alert(1);
    """)
    
    taptool = p.select(type=TapTool)
    taptool.callback = tapcallback
    
    if showplot:
        show(p)
    else:
        return p
