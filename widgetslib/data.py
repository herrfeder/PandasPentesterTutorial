import pandas as pd
import sqlalchemy
from sqlalchemy.sql import select
from sqlalchemy import MetaData
from widgetslib.datasupport import *

class DataAPI():
    
    def __init__(self, datascope):
        
        self.conn = sqlalchemy.create_engine("sqlite:///data/"+datascope+".db")
        self.meta = MetaData(self.conn,reflect=True)
        self.portscan = self.meta.tables['portscan']
        self.dirtraversal = self.meta.tables['dirtraversal']
        
    def return_table(self, table_name):
        
        if table_name not in self.conn.table_names():
            return "Wrong tablename"
        else:
            return pd.read_sql_table(table_name, self.conn)
        
    def return_domain_list(self):
        
        return pd.read_sql_table("subdomain", self.conn)['domain'].values
    
    def return_ip_list(self):
        
        return pd.read_sql_table("subdomain", self.conn)['ip4_1'].values
    
    def return_dirtraversal(self, domain):
        '''
        Returns a directory traversal scan for one or multiple Domains. As a single IP could be used for multiple domains.
        '''
        final_result = {}
        stats_result = {}
        overview_dt = "### Dirtraversal Stats\n"

        for single_domain in domain:
            s = select([self.dirtraversal]).where(self.dirtraversal.c.domain == single_domain)
            temp_result = pd.read_sql(s, self.conn)
            
            if temp_result.shape[0] > 0:
                stats_result[single_domain+'_number'] = temp_result.shape[0]
                stats_result[single_domain+'_200'] = temp_result[temp_result.status == "200"].shape[0]
                stats_result[single_domain+'_401'] = temp_result[temp_result.status == "401"].shape[0]
                stats_result[single_domain+'_403'] = temp_result[temp_result.status == "403"].shape[0]

                final_result[single_domain] = temp_result
                
                
                test=single_domain+'_'+'403'
        
                overview_dt = overview_dt + """
                #### {0}
                  * {1} paths resolved
                  * {2} 200 responses
                  * {3} 401 responses
                  * {4} 403 responses
              
                """.format(single_domain,
                           stats_result[single_domain+'_number'],
                           stats_result[single_domain+'_200'],
                           stats_result[single_domain+'_401'],
                           stats_result[single_domain+'_403'])
                
            
            
        return (final_result, overview_dt)
            
            
    
    
    def return_portscan(self, ip):
        
        stats_result = {}
        
        s = select([self.portscan]).where(self.portscan.c.ip == ip)
        result = pd.read_sql(s, self.conn)
        
        if result.shape[0] > 1:
            df = extract_scan(result.iloc[0])
            
            stats_result['open'] = df[df.state == "open"].shape[0]
            stats_result['filtered'] = df[df.state == "filtered"].shape[0]
            
            overview_ps = """
            ### {} Portscan Stats
              * {} open ports
              * {} filtered ports
            """.format(ip,
                   stats_result['open'],
                   stats_result['filtered'])
            
            return (df, overview_ps)
        
        elif result.shape[0] == 0:
            return pd.DataFrame()
        
        else:
            df = extract_scan(result)
            
            stats_result['open'] = df[df.status == "open"].shape[0]
            stats_result['filtered'] = df[df.status == "filtered"].shape[0]
            
            overview_ps = """
            ### {} Portscan Stats
              * {} open ports
              * {} filtered ports
            """.format(ip,
                   stats_result['open'],
                   stats_result['filtered'])
            
            
            return (df, overview_ps)
            
        
    def ip_to_domain(self, ip):
        
        df = self.return_table("subdomain")
        
        if not df.empty:
            return list(df.query("ip4_1==@ip")["domain"].values)
        else:
            return ""

    def domain_to_ip(self, domain):
        
        df = self.return_table("subdomain")
        
        if not df.empty:
            return df.query("domain==@domain")["ip4_1"].values
        else:
            return ""
