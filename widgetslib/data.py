import pandas as pd
import sqlalchemy
from sqlalchemy.sql import select
from sqlalchemy import MetaData
from widgetslib.datasupport import *

class DataAPI():
    
    def __init__(self, datascope):
        
        self.conn = sqlalchemy.create_engine("sqlite:///data/"+datascope+".db")
        self.meta = MetaData(self.conn,reflect=True)
        self.portscan = self.meta.tables['portscan']
        self.dirtraversal = self.meta.tables['dirtraversal']
        
    def return_table(self, table_name):
        
        if table_name not in self.conn.table_names():
            return "Wrong tablename"
        else:
            return pd.read_sql_table(table_name, self.conn)
        
    def return_domain_list(self):
        
        return pd.read_sql_table("subdomain", self.conn)['domain'].values
    
    def return_ip_list(self):
        
        return pd.read_sql_table("subdomain", self.conn)['ip4_1'].values
    
    def return_dirtraversal(self, domain):
        '''
        Returns a directory traversal scan for one or multiple Domains. As a single IP could be used for multiple domains.
        '''
        final_result = {}
        
        for single_domain in domain:
            s = select([self.dirtraversal]).where(self.dirtraversal.c.domain == single_domain)
            temp_result = pd.read_sql(s, self.conn)
            
            if temp_result.shape[0] > 0:
                final_result[single_domain] = temp_result
                
        return final_result
            
            
    
    
    def return_portscan(self, ip):
        
        s = select([self.portscan]).where(self.portscan.c.ip == ip)
        result = pd.read_sql(s, self.conn)
        
        if result.shape[0] > 1:
            return extract_scan(result.iloc[0])
        
        elif result.shape[0] == 0:
            return "noportscan"
        
        else:
            return extract_scan(result)
        
    def ip_to_domain(self, ip):
        
        df = self.return_table("subdomain")
        
        if not df.empty:
            return list(df.query("ip4_1==@ip")["domain"].values)
        else:
            return ""

    def domain_to_ip(self, domain):
        
        df = self.return_table("subdomain")
        
        if not df.empty:
            return df.query("domain==@domain")["ip4_1"].values
        else:
            return ""
